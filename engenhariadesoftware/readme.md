----- Atividade 1. Comentar com suas palavras o primeiro trecho do livro Software Engineering at Google, Oreilly. 

Programar e fazer engenharia de software não são a mesma atividade. No uso cotidiano, os termos se confundem, mas na prática apontam para responsabilidades distintas. Programar é o ato de produzir código para resolver um problema específico, geralmente com foco no curto prazo. Engenharia de software, por sua vez, pressupõe aplicar princípios e conhecimento técnico para construir sistemas reais, organizados e confiáveis, em um nível comparável ao de engenharias tradicionais como a civil ou a mecânica.

A diferença é que, nessas engenharias clássicas, normas e métodos foram consolidados porque erros podem causar danos físicos. Em software isso nem sempre existiu com o mesmo rigor. Só que, como hoje programas controlam desde bancos até hospitais, o desenvolvimento precisa ser conduzido com processos mais sólidos, critérios de qualidade e preocupação com segurança e confiabilidade ao longo do tempo.
 
----- Atividade 2. Comentar com suas palavras o segundo trecho do livro Software Engineering at Google, Oreilly.

“Engenharia de software” vai muito além de escrever funções. Ela abrange o conjunto de práticas, processos e ferramentas que mantêm um sistema útil e saudável durante todo o seu ciclo de vida. Em outras palavras, é a programação pensada ao longo do tempo: da concepção inicial à manutenção, evolução contínua e, quando necessário, a desativação controlada.

Três fundamentos devem orientar as decisões técnicas:

Tempo e mudança: aceite que o software irá evoluir; projete para facilitar alteração, correção e adaptação.

Escala e crescimento: considere como equipe, dados e tráfego vão aumentar e o que isso exige de arquitetura e operações.

Trade-offs e custos: toda decisão tem preço; compare alternativas olhando impactos presentes e futuros.
 
----- Atividade 3. Listar e explicar 3 exemplos de tradeoffs

1) Entrega rápida × Qualidade do código
Pressões de prazo podem levar a pular testes, ignorar padrões e “dar um jeitinho” para lançar logo. Funciona no curto prazo, mas costuma gerar dívida técnica, dificultando manutenção e aumentando risco de falhas. A pergunta honesta é: o ganho imediato compensa o retrabalho e os bugs futuros?

2) Arquitetura sofisticada × Facilidade de manutenção
Soluções mais complexas podem suportar cenários avançados e escalar melhor. Em contrapartida, multiplicam camadas e abstrações, elevando a curva de aprendizado e tornando mudanças triviais mais custosas. Vale ponderar se o benefício de longo prazo supera a complexidade extra no dia a dia.

3) Desempenho extremo × Legibilidade do código
Algumas otimizações rendem milissegundos a menos, mas exigem técnicas obscuras ou código menos legível. No futuro, isso pode dificultar correções e evoluções. É preciso decidir quando a clareza e a manutenção pesam mais do que o ganho marginal de performance.


----- Atividade 4. UML

![imagem uml da atividade](https://github.com/brendabettini/bertoti/blob/main/m%C3%ADdia/UML%20-%20Atividade%203.jpg)


